import tensorflow as tf
import multiprocessing
import time
import numpy as np
import aux.misc

class trainer_thread(multiprocessing.Process):
    def __init__(self,trainer, runner_threads, train_epochs, patience=0.1):
        multiprocessing.Process.__init__(self, target=self, args=())
        self.trainer = trainer
        self.runner_threads = runner_threads
        self.train_epochs = train_epochs
        self.running = False
        self.patience = patience
        self.settings = settings
    def __call__(self, *x, **kx):
        self.run()
    def run(self):
        print("trainer bypassed...")
        return
        self.running = True
        # current_idx       = [0 for _ in runners]
        # current_iteration = [1 for _ in runners] #These are for the non-primitive solution...
        all_data = []
        # while ( np.array(current_iteration) < self.train_epochs ).any():
        for r in self.runner_threads:
            '''PRIMITIVE SOLUTION!'''
            while r.running:
                pass
            '''
            DESIRABLE: start processing the first epoch on the samples
            generated by the runner, as they are coming in
            '''
        #     all_data += r.agent.get_train_data()
        # self.trainer.do_training(all_data, self.train_epochs)
        self.running = False

    def join(self):
        while self.running:
            time.sleep(self.patience)

class runner_thread(multiprocessing.Process):
    def __init__(self, id, settings=None, return_queue=None):
        multiprocessing.Process.__init__(self, target=self, args=(return_queue,))
        self.id = id
        self.running = False
        self.settings = settings
        self.return_queue = return_queue
        self.current_player = 1

    def __call__(self, q):
        self.run()

    # def join(self):
    #     while self.running:
    #         time.sleep(self.patience)

    def run(self):
        with tf.Session() as session:
            #Initialize!
            self.env = self.settings["env_vector_type"](
                                                    self.settings["n_envs_per_thread"],
                                                    self.settings["env_type"],
                                                    settings=self.settings
                                                    )
            self.agent = self.settings["agent_type"](
                                                self.settings["n_envs_per_thread"],
                                                id=self.id,
                                                sandbox=self.settings["env_type"](settings=self.settings),
                                                session=session,
                                                settings=self.settings,
                                                )
            print("UGLY INITIALIZATION OF TF-STUF...")
            session.run(tf.global_variables_initializer())
            self.agent.reinitialize_model()

            self.n_steps = self.settings["worker_steps"]
            #Run!
            T_thread_start = time.time()
            self.running = True
            s = self.env.get_state()
            for t in range(0,self.n_steps):
                print("worker{}:{}".format(self.id,t))
                self.current_player = 1 - self.current_player
                _,a = self.agent.get_action(s, player=self.current_player)
                # a = self.env.get_random_action()
                ds = self.env.perform_action(a)
                s = self.env.get_state()
                for i,d in enumerate(ds):
                    if d: self.env.reset(env=[i])
            print("worker{} done".format(self.id))
            T_thread_stop = time.time()
            self.return_queue.put(T_thread_stop-T_thread_start)
            self.running = False

class threaded_runner:
    def __init__(self, settings=None):
        self.threads = []
        self.return_queue = multiprocessing.Queue()
        # runner_threads = []
        patience = settings["process_patience"]
        if type(patience) is list: runner_patience, trainer_patience, self.patience = patience
        else: runner_patience = trainer_patience = self.patience = patience
        for i in range(settings["n_workers"]):
            thread = runner_thread(
                                   i,
                                   settings=settings,
                                   return_queue=self.return_queue,
                                   )
            self.threads.append(thread)
        # self.trainer = trainer_thread(
        #                                 id="trainer",
        #                                 settings=settings,
        #                                 session=session,
        #                              )
        # self.threads.append(trainer_thread)

    def sum_return_que(self):
        ret = 0
        while not self.return_queue.empty():
            ret += self.return_queue.get()
        return ret

    def run(self, steps):
        p = multiprocessing.Pool(len(self.threads))
        print("pool created")
        for thread in self.threads:
            thread.start()

    def join_all_threads(self):
        print("Tring to join...")
        for thread in self.threads:
            while thread.running:
                time.sleep(self.patience)
            thread.join()
        print("join done!")

    def join(self):
        self.join_all_threads()
